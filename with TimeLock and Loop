#import "Lib_v0+equal+know";
#define time 1;
#define Going 5;
#define Off 6;
#define Notification1 7;
#define Notification2 7;
#define Notification3 7;
#define Notification4 7;
#define NewBlockNotification 7;
#define HashResult 7;
#define HashResultConfirm 7;
#define LoginNewTransaction 7;
#define CheckingBurnAssetTransaction 8;
#define ReclaimCheck 8;
#define N 9;
#define Bill_Registration 1;


// Keys exchange
channel SenderAndRecipient 0;
channel SenderAndSourceChain 0;
channel RecipientAndSourcechain 0;
channel SourceChainAndSourceMiner 0;
channel DestinationAndSourceMiner 0;
channel SourceAndDestination 0;
channel DestinationAndDestinationMiner 0;
channel SourceAndDestinationMiner 0;
channel SenderAndDestination 0;
channel RecipientAndDestination 0;
channel SourceMinerAndEvent 0;
channel DestinationMinerAndEvent 0;
channel SenderAndFakeRecipient 0;

channel SourceChainAndEvent 0;
channel DestinationAndEvent 0;

channel Miner1AndSourceMiner 0;
channel Miner2AndSourceMiner 0;
channel Miner1AndDestinationMiner 0;
channel Miner2AndDestinationMiner 0;

//var SecredCode = 1;
var<SKey> SKsender = new SKey();
var<PKey> PKsender = new PKey(SKsender); 
var<SKey> SKreceive = new SKey();
var<PKey> PKreceive = new PKey(SKreceive); 
var<Nonce> SecredCode = new Nonce();
var<Nonce> SecredCodeF = new Nonce();

var<SEnc> cipherScode;                     
var<SDec> decipherScode;

var TimeLockEnough = 2;
var TimeLockNotEnougt = 0;
#define TimeLock 2;


var moneyS = 10;
var moneySnew;

var moneyR = 0;
var moneyRnew = 0;
var moneyRnew1 = 0;
var moneyRnew2 = 0;
var moneyRnew3 = 0;

var asset = 9;
var BurnAddress = 0;   
var Address = [BurnAddress, asset];
var NewBlock = [0,0,0,0,0,0];

var TXmind;
var EntryTransaction;
var Miner_verification;
var Miner_verified_successfully = 1;
var Result;
var Proof_Of_Work;

var Event1 = [BurnAddress, SecredCode, TimeLock, asset];
var Event2 = [TXmind, BurnAddress, SecredCode, TimeLock, asset];
var Event3 = 0;
var n = 0;

var moneyS_enought = false;
var moneySnewCheck = false;
var fakerecipientHasNoTruePk = false;
var reclaimResult = false;

//ExitTransaction = exitTransaction{moneySnew = moneyS - asset;moneySnewCheck = true} -> Skip;


sender(i) = SenderAndRecipient!PKsender -> SenderAndFakeRecipient!PKsender -> SenderAndRecipient?Var_PKreceive -> SenderAndFakeRecipient?Var_PKreceive1 -> 
SenderAndRecipient?AddressNew.SecredCodeNew -> SenderAndFakeRecipient?AddressNew1.SecredCodeNew1 -> tau{cipherScode = new SEnc(new Pair(PKreceive,SecredCodeNew), SKsender);} -> 
SenderAndRecipient!cipherScode ->  // SecredCode,PKreceive   Unity type?
tau{if(moneyS>asset && TimeLock > 0)
                      {moneySnew = moneyS - asset; 
                       moneySnewCheck = true;}} -> tau{if(moneySnew >= 0){moneyS_enought = true;}}->
tau{BurnAddress = BurnAddress + asset;} -> SenderAndSourceChain!BurnAddress.asset.cipherScode.TimeLock -> SenderAndDestination?Notification3 ->
tau{if(TimeLock == TimeLockEnough)
       {reclaimResult = true;}
    else
       {reclaimResult = false;
        moneySnew = moneySnew + asset;}} ->
SenderAndSourceChain!reclaimResult -> sender(i);
                   

recipient(i) = SenderAndRecipient?Var_PKsender -> SenderAndRecipient!PKreceive -> SenderAndRecipient!Address.SecredCode -> SenderAndRecipient?cipherScodeNew -> 
RecipientAndSourcechain?Notification2 -> (tau{decipherScode = new SDec(cipherScodeNew,SKreceive);} ->   // cipherScode
tau{if(BurnAddress == asset && decipherScode == cipherScodeNew)  // && decipherScode == SecredCode    Problem && time<TimeLock
      {moneyRnew = moneyR + asset;}} ->
RecipientAndDestination!BurnAddress.SecredCode.asset -> RecipientAndDestination?Notification3 -> RecipientAndDestination?reclaimResult2 -> 
tau{if(reclaimResult == true)
      {moneyRnew = moneyRnew - 0;}
    else{moneyRnew = moneyRnew - asset;}} -> recipient(i) within[TimeLock]); 


FakeRecipient(i) = SenderAndFakeRecipient?Var_PKsender1 -> SenderAndFakeRecipient!PKreceive -> PKcheck -> SenderAndFakeRecipient!Address.SecredCode -> 
(tau{if(decipherScode != SecredCodeF) //&& time<TimeLock
    {fakerecipientHasNoTruePk = true;}
    else{fakerecipientHasNoTruePk = false;}} -> Skip within[TimeLock]);


SourceChain(i) = SenderAndSourceChain?BurnAddressNew.assetNew.cipherScodeNew.TimeLockNew -> SourceChainAndSourceMiner!Notification1.cipherScode -> SourceChainAndSourceMiner?TXmindNew -> 
RecipientAndSourcechain!Notification2 -> SourceChainAndEvent!Event1 -> (SourceAndDestinationMiner?CheckingBurnAssetTransactionNew -> SourceChainAndSourceMiner!SKsender -> 
SenderAndSourceChain?reclaimResult1 -> SourceAndDestination!reclaimResult1 -> SourceChainAndEvent!Event3 -> SourceChain(i) within[TimeLock]);


DestinationChain(i) = (RecipientAndDestination?BurnAddressNew.SecredCodeNew.assetNew -> DestinationAndDestinationMiner!Notification4.SecredCodeNew -> DestinationAndDestinationMiner?TXmindNew -> 
SenderAndDestination!Notification3 -> RecipientAndDestination!Notification3 -> DestinationAndEvent!Event2 -> DestinationAndSourceMiner!SKreceive -> SourceAndDestination?reclaimResult2 ->
 RecipientAndDestination!reclaimResult2 -> DestinationChain(i) within[TimeLock]);


SourceMiner(i) = SourceChainAndSourceMiner?Notification1.cipherScodeNew -> SourceChainAndSourceMiner!TXmind ->  tau{if(moneyS >= 0){Miner_verification = Miner_verified_successfully;}} -> Hash_calculation -> 
tau{Result = new Hash(cipherScodeNew)} -> Miner1AndSourceMiner!Result ->  Miner2AndSourceMiner!Result -> CreateNewBlock -> SourceMinerAndEvent!NewBlockNotification -> 
(SourceChainAndSourceMiner?SKsenderNew -> DestinationAndSourceMiner?SKreceiveNew -> SourceMiner(i) within[TimeLock]);

DestinationMiner(i) = (DestinationAndDestinationMiner?Notification4.SecredCodeNew1 -> tau{if(moneyRnew >= asset && BurnAddress == 9 ){Miner_verification = Miner_verified_successfully;}} -> Hash_calculation -> 
Miner1AndDestinationMiner!Result -> Miner2AndDestinationMiner!Result -> tau{NewBlock[n] = Bill_Registration;} -> DestinationMinerAndEvent!NewBlockNotification -> 
SourceAndDestinationMiner!CheckingBurnAssetTransaction -> DestinationAndDestinationMiner!TXmind -> DestinationMiner(i) within[TimeLock]);

Miner1(i) = (Miner1AndSourceMiner?ResultNew -> ResultVerification -> Miner1AndDestinationMiner?ResultNew -> ResultVerification -> tau{NewBlock[n+1] = 1;} -> Miner1(i) within[TimeLock]);  

Miner2(i) = (Miner2AndSourceMiner?ResultNew -> ResultVerification -> Miner2AndDestinationMiner?ResultNew -> ResultVerification -> tau{NewBlock[n+2] = 1; n++} -> Miner2(i) within[TimeLock]);

Event(i) = SourceMinerAndEvent?NewBlockNotificationNew -> SourceChainAndEvent?Event1New -> (DestinationMinerAndEvent?NewBlockNotificationNew -> 
DestinationAndEvent?Event2New -> SourceChainAndEvent?Event3New -> Event(i) within[TimeLock]);

// ReclaimProcess(i) = redo -> protocol();


protocol() = sender(10) || recipient(10) || SourceChain(10) || DestinationChain(10) || SourceMiner(10) || Event(10) || DestinationMiner(10) || Miner1(10) || Miner2(10) ||FakeRecipient(10);

#assert protocol() deadlockfree;

#define BurnAddressVerification (BurnAddress == 9 && moneySnew == 1);
#assert protocol() |= <>[] BurnAddressVerification;

#define assetCheck (moneySnew == 1 && moneyRnew == 9 && fakerecipientHasNoTruePk == true);   //moneyS = 10  moneyR = 0   //什么是正确的receive
#assert protocol() |= <>[] assetCheck;

#define FakeRecieveCheck (fakerecipientHasNoTruePk == true && decipherScode != SecredCode);
#assert protocol() |= <>[] FakeRecieveCheck;


// #define BurnbeforeClaim (BurnAddress == 10); // (!(moneySnew == 0) U BurnAddress/\(<> (moneySnew == 0)))   // LTL的图 p93 (! t U b) /\ (<>t)
#define MoneyCheck (moneySnewCheck == true);
#define BurnAddressCheck (BurnAddress == 10);
#assert protocol() |= [] (([] !MoneyCheck) || (!MoneyCheck U BurnAddressCheck));

#define sender_has_enought_Money (moneyS_enought == true);  
#assert protocol() reaches sender_has_enought_Money;

#define Reclaim (reclaimResult == true && moneySnew == 1);
#assert protocol() |= <>[] Reclaim;

// #define MinerVerification (NewBlock == [0,0,0,0,0,0]);
// #assert protocol() |= <>[] MinerVerification;

#define assetCheck_Miner (Miner_verification == 1);
#assert protocol() |= <>[] assetCheck_Miner;

#import "Lib_v0+equal+know";
#define TimeLock 5;
#define N 4;
#define Notification1 10;
#define Notification2 11;
#define Notification3 12;
#define Go 1;
#define Off 0;

channel SenderAndRecipient 0;
channel SenderAndSourceChain 0;
channel RecipientAndSourcechain 0;
channel SourceChainAndSourceMiner 0;
channel DestinationAndSourceMiner 0;
channel SourceAndDestination 0;
channel DestinationAndDestinationMiner 0;
channel SourceAndDestinationMiner 0;
channel SenderAndDestination 0;
channel RecipientAndDestination 0;
channel SourceMinerAndEvent 0;
channel DestinationMinerAndEvent 0;
channel SenderAndFakeRecipient 0;

channel SourceChainAndEvent 0;
channel DestinationAndEvent 0;

channel Miner1AndSourceMiner 0;
channel Miner2AndSourceMiner 0;
channel Miner1AndDestinationMiner 0;
channel Miner2AndDestinationMiner 0;

var<SKey> SKsender = new SKey();
var<PKey> PKsender = new PKey(SKsender); 
var<SKey> SKreceive = new SKey();
var<PKey> PKreceive = new PKey(SKreceive); 
var<Nonce> Message = new Nonce();

var<SEnc> cipherScode;                     
var<SDec> decipherScode;

var moneyS = 10;
var moneySnew;
var moneyR = 0;
var moneyRnew = 0;

var asset = 9;
var BurnAddress = 0;   

var AddressR = [PKreceive, SKreceive, moneyS];
var AddressS = [PKsender, SKsender, moneyR];

var Event1 = [PKreceive, Message, asset];
var Event2 = [PKsender, Message, asset];
var Event3 = 0;

var moneyS_enought = false;
var moneySnewCheck = false;
var fakerecipientHasNoTruePk = false;
var reclaimResult = false;
var resultVerification1 = false;
var resultVerification2 = false;

var digital_signature;
var encrypted_inf;
var decrypted_inf;

// digital_signature = Digital_Signature{new Pair(PKreceive,Message)} -> Skip;


sender() = SenderAndRecipient!PKsender -> 
SenderAndRecipient?PKreceive1 -> 
SenderAndRecipient?SKreceive1.BurnAddress1 -> 
Digital_Signature{digital_signature = new Pair(PKreceive1,Message);} -> 
Encrypted_inf{encrypted_inf = new SEnc(new Pair(PKreceive1,Message), SKsender);} -> 
SenderAndSourceChain!encrypted_inf.asset.BurnAddress1.digital_signature.PKsender -> sender();

SourceChain() = SenderAndSourceChain?encrypted_inf1.asset1.BurnAddress2.digital_signature1.PKsender1 -> 
ExitTransaction{if(digital_signature1==digital_signature && PKsender1==PKsender && moneyS>=asset1)    //ExitTransaction
                  {moneySnew = moneyS - asset1;}} -> 
Burn_Transaction{if(moneySnew <= moneyS)     //Burn_Transaction
                    {BurnAddress = BurnAddress + asset1;}} -> 
SourceAndDestination!moneySnew.BurnAddress.encrypted_inf1.digital_signature1.asset1  -> 
SourceChainAndSourceMiner!moneySnew.BurnAddress.encrypted_inf1.digital_signature1.asset1 -> SourceChain(); //-> SourceChainAndEvent!Event1

DestinationChain() = SourceAndDestination?moneySnew1.BurnAddress1.encrypted_inf2.digital_signature2.asset2 ->
EntryTransaction{if(moneySnew1<=moneyS && BurnAddress1==asset2 && encrypted_inf2==encrypted_inf && digital_signature2 == digital_signature)  // EntryTransaction
                 {decrypted_inf = new SDec(encrypted_inf2,SKsender);}} ->
AssetCreate{if(decrypted_inf == encrypted_inf2)  // AssetCreate
               {moneyRnew = moneyR + asset2;}} -> 
RecipientAndDestination!moneyRnew -> DestinationAndDestinationMiner!decrypted_inf.encrypted_inf2 -> DestinationChain();

recipient() = SenderAndRecipient?PKsender1 -> 
SenderAndRecipient!PKreceive -> 
SenderAndRecipient!SKreceive.BurnAddress -> 
RecipientAndDestination?moneyRnew1 -> recipient();

SourceMiner() = SourceChainAndSourceMiner?moneySnew11.BurnAddress11.encrypted_inf111.digital_signature111.asset111 -> 
ResultVerification{if(moneySnew11<=moneyS && BurnAddress11==asset){resultVerification1 = true;}} -> SourceMiner();

DestinationMiner() = DestinationAndDestinationMiner?decrypted_inf1.encrypted_inf21 ->
ResultVerification{if(decrypted_inf1 == encrypted_inf21){resultVerification2 = true;}} -> DestinationMiner();

Event() = Skip;

protocol() = sender() || recipient() || SourceChain() || DestinationChain() || SourceMiner() || Event() || DestinationMiner();  // || Miner1() || Miner2();


#assert protocol() deadlockfree;

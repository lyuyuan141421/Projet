#import "Lib_v0+equal+know";
#define TimeLock 1;
#define Going 5;
#define Off 6;
#define Notification 7;
#define TXmind 7;

// Keys exchange
channel SenderAndRecipient 0;
channel SenderAndSourceChain 0;
channel RecipientAndSourcechain 0;
channel SourceChainAndSourceMiner 0;

channel SourceChainAndEvent 0;


var<SKey> SKsender = new SKey();
var<PKey> PKsender = new PKey(SKsender); 
var<SKey> SKreceive = new SKey();
var<PKey> PKreceive = new PKey(SKreceive); 

var<PEnc> cipherScode;
var<PDec> decipherScode;

var money;
var BurnAddress = 1;
var SecredCode = 1;   
var Address = [SecredCode, BurnAddress, money];
var Encrypt = [SecredCode, cipherScode];
var Event1 = [BurnAddress, SecredCode, TimeLock, money];

var ExitTransaction;
var going;
var off;

sender() = SenderAndRecipient!PKsender -> SenderAndRecipient?Var_PKreceive -> SenderAndRecipient?AddressNew -> SenderAndRecipient!SecredCode.cipherScode ->  
SenderAndSourceChain!ExitTransaction{if(money>=0 && BurnAddress == true && TimeLock == true && cipherScode == true )  // something wrong
                      {going = Going;}
                   else
                      {off = Off;}} -> 
SenderAndRecipient!decipherScode -> Skip;
                   

receive() = SenderAndRecipient?Var_PKsender -> SenderAndRecipient!PKreceive -> SenderAndRecipient!Address -> SenderAndRecipient?SecredCodeNew.cipherScodeNew -> 
RecipientAndSourcechain?NotificationNew -> SenderAndRecipient?decipherScodeNew -> Skip;


SourceChain() = SenderAndSourceChain?ExitTransactionNew -> SourceChainAndSourceMiner!Notification -> SourceChainAndSourceMiner?TXmindNew -> RecipientAndSourcechain!Notification -> 
SourceChainAndEvent!Event1 -> Skip;


DestinationChain() = Skip;


SourceMiner() = SourceChainAndSourceMiner?NotificationNew -> SourceChainAndSourceMiner!TXmind -> Skip;

Event() = SourceChainAndEvent?Event1New ->Skip;



protocol() = sender() || receive() || SourceChain() ||DestinationChain() || SourceMiner() || Event();
